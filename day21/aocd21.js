const inp = `../.. => ###/.#./.##
#./.. => .../###/#.#
##/.. => #.#/..#/..#
.#/#. => ##./.##/..#
##/#. => ###/.../###
##/## => ###/##./.#.
.../.../... => .#../..##/...#/....
#../.../... => .#../..##/.##./####
.#./.../... => .#../###./.#../#..#
##./.../... => #.##/#..#/...#/.#..
#.#/.../... => ##.#/.#.#/#.#./..##
###/.../... => #..#/#.##/..../#.##
.#./#../... => .#.#/.#../..../.#.#
##./#../... => ###./..../.##./###.
..#/#../... => .#../###./####/.#..
#.#/#../... => ..##/.#../#.#./##.#
.##/#../... => #..#/##../.###/#...
###/#../... => #.##/##../.#.#/####
.../.#./... => ####/.###/..#./###.
#../.#./... => ###./..../#.../#...
.#./.#./... => .#../###./.#.#/....
##./.#./... => #.##/#..#/.#.#/##..
#.#/.#./... => #.../..../##../....
###/.#./... => ..../...#/##../####
.#./##./... => ..../.###/.#.#/#...
##./##./... => ..##/.##./###./#.##
..#/##./... => ...#/#.#./#.#./#..#
#.#/##./... => ..##/###./#.##/..#.
.##/##./... => .###/..../##../#.##
###/##./... => .#../...#/..##/##..
.../#.#/... => ...#/#.##/#.../####
#../#.#/... => .##./.#../###./.###
.#./#.#/... => ##.#/.#.#/#.../.##.
##./#.#/... => ####/#..#/..#./....
#.#/#.#/... => #.##/.##./####/.#..
###/#.#/... => ..##/..#./#..#/.#..
.../###/... => #..#/#.../.##./.##.
#../###/... => ##../###./#.##/####
.#./###/... => .#../..##/#..#/...#
##./###/... => ..#./#..#/.###/..#.
#.#/###/... => #..#/#.#./#.#./#.##
###/###/... => #.../.##./..../.##.
..#/.../#.. => .###/.##./.##./#.##
#.#/.../#.. => #.../..#./.###/...#
.##/.../#.. => #..#/..../.##./.#.#
###/.../#.. => .##./##.#/.#.#/##..
.##/#../#.. => ...#/#.##/.#../.#..
###/#../#.. => ##.#/#.#./#.../##..
..#/.#./#.. => .#../#.../#.../####
#.#/.#./#.. => .##./.##./#.##/.#.#
.##/.#./#.. => ##../.#.#/#.../.#..
###/.#./#.. => ..#./.#../..#./.###
.##/##./#.. => #.../#..#/..##/###.
###/##./#.. => ..../#..#/.#../####
#../..#/#.. => ..#./#.#./####/#...
.#./..#/#.. => .##./.###/#.../#.#.
##./..#/#.. => ##../.#.#/...#/#.##
#.#/..#/#.. => ####/###./##.#/...#
.##/..#/#.. => ##.#/###./#..#/###.
###/..#/#.. => .###/#..#/...#/.#.#
#../#.#/#.. => ##../##../#.../##.#
.#./#.#/#.. => #.../.###/...#/..#.
##./#.#/#.. => .#../..../#..#/..##
..#/#.#/#.. => ##../##.#/..#./#..#
#.#/#.#/#.. => .#../###./#.##/#.##
.##/#.#/#.. => ..../..#./#..#/####
###/#.#/#.. => ####/.#.#/...#/###.
#../.##/#.. => .#.#/#.##/##.#/.###
.#./.##/#.. => ##.#/#.#./.#.#/.##.
##./.##/#.. => .##./#.#./..../.#..
#.#/.##/#.. => ###./.#../#.../....
.##/.##/#.. => #.##/##../#.##/...#
###/.##/#.. => .##./..../...#/##..
#../###/#.. => #..#/#..#/#..#/####
.#./###/#.. => .#.#/#.#./.#.#/####
##./###/#.. => ##../#.#./#..#/....
..#/###/#.. => .##./##../..../###.
#.#/###/#.. => ..##/#.../#.../#.#.
.##/###/#.. => ..##/##.#/#.##/#.##
###/###/#.. => .#.#/..##/###./.#..
.#./#.#/.#. => ..../.#../.###/.#..
##./#.#/.#. => ...#/#.../.#.#/...#
#.#/#.#/.#. => ..../..##/..../.#..
###/#.#/.#. => #.#./#.##/##../###.
.#./###/.#. => #.##/..#./.#../###.
##./###/.#. => .#../..##/...#/#.#.
#.#/###/.#. => #.../...#/###./#...
###/###/.#. => ..##/##.#/..#./#.#.
#.#/..#/##. => .#.#/#.#./####/..#.
###/..#/##. => #..#/##.#/..../#...
.##/#.#/##. => #..#/...#/#.##/.#..
###/#.#/##. => .#.#/###./#.../#.##
#.#/.##/##. => .#../#.#./.#../..#.
###/.##/##. => ..#./##../##../.###
.##/###/##. => .###/#.##/##../.##.
###/###/##. => ..##/#.../.#.#/..##
#.#/.../#.# => .#../.#../##.#/.##.
###/.../#.# => .#.#/...#/.#../#.#.
###/#../#.# => ...#/#..#/..#./.###
#.#/.#./#.# => ##../##.#/####/...#
###/.#./#.# => .#.#/...#/..#./#..#
###/##./#.# => .###/##.#/.#../#.##
#.#/#.#/#.# => #.../#.../.#.#/...#
###/#.#/#.# => .#../#.#./##.#/..#.
#.#/###/#.# => .###/#..#/####/####
###/###/#.# => ####/#..#/.##./#...
###/#.#/### => #.#./..##/#.../#.#.
###/###/### => .###/.##./#.#./...#`;

const lines = inp.split("\n");

flip = matrix => matrix[0].map((col, i) => matrix.map(row => row[i]));

rotate = matrix => flip(matrix.reverse());

convertToArr = str => str.split('/').map(w => w.split(''));

key = matrix => matrix.join('/').split(',').join('');

countHash = (matrix) => key(matrix).split("#").length - 1;

let start = convertToArr(".#./..#/###");
let map = {};
let round = 18;
let count = 0;

lines.forEach (line => {
    let word = line.split(" => ");
    for(let i=0; i<4; i++) {
        for(let j=0; j< 2; j++) {
            let grid = convertToArr(word[0]);
            for(let k=0; k<i; k++) {
                grid = rotate(grid);
            }
            for(let l=0; l<j; l++) {
                grid = flip(grid);
            }
            map[key(grid)] =  word[1];
        }
    }
});

function getGrid(grid) {
    const len = grid.length;
    let split = 0;
    let splitval = 0;
    let n = 0;
    let out = [];
    if(len % 2 === 0) {
        n = Math.floor(len/2) * 3;
        split = 2;
    } else {
        n = Math.floor(len/3) * 4;
        split = 3;
    }
    for(let i =0; i< Math.floor(len/split); i++) {
        for(let j =0; j< Math.floor(len/split); j++) {
            let ii = i * split;
            let jj = j * split;
            let newGrid = [];
            let row = 0;
            for(let r = ii; r< ii+split; r++) {
                let column = 0;
                newGrid[row] = [];
                for(let c = jj; c < jj+split; c++) {                    
                    newGrid[row][column] = grid[r][c];
                    column++;
                }
                row++;
            }
            const newArr = convertToArr(map[key(newGrid)]);
            
            let newii = i * (split+1);
            let newjj = j * (split+1);
            for(let r = 0; r < (split+1); r++) {
                    if(!out[newii+r]) {
                        out[newii+r] = [];
                    }
                for(let c = 0; c < (split+1); c++) {
                    out[newii+r][newjj+c]= newArr[r][c]; 
                }
            }
        }
    }
    return out;
}

while(count < round) {
    start = getGrid(start);
    count++;
}

console.log(countHash(start));